include "mem.nhp"

mod data:
	class list<T>:
		handle buffer
		int count = 0
		int capacity
		
		def __init__(int capacity):
			cdef malloc(int) handle
			self.capacity = capacity
			self.buffer = malloc(capacity * sizeof(T))
		
		def __del__():
			cdef free(handle) None
			free(self.buffer)
		
		def __copy__() list<T>:
			copied = new list<T>(self.count)
			copied.count = self.count
			for i from 0 within self.count:
				copied.buffer{copied}[i] = self.buffer[i] as T
			return copied
		
		def getAtIndex(int i) T:
			if i < 0 or i >= self.count:
				abort "Index out of range."
			return self.buffer[i]
		def setAtIndex(int i, T elem) T:
			if i < 0 or i >= self.count:
				abort "Index out of range."
			return self.buffer{self}[i] = elem
		
		def pushBack(T elem):
			if self.count == self.capacity:
				cdef realloc(handle, int) handle
				self.capacity = self.capacity + 10
				self.buffer = realloc(self.buffer, self.capacity * sizeof(T))
			self.buffer{self}[self.count] = elem
			self.count = self.count + 1
		
		def addBuffer(array<T> buf):
			if self.count + buf as int > self.capacity:
				cdef realloc(handle, int) handle
				self.capacity = self.count + buf as int
				self.buffer = realloc(self.buffer, self.capacity * sizeof(T))
			for i from 0 within buf:
				self.buffer{self}[self.count + i] = buf[i]
			self.count = self.count + buf as int
		def addRange(list<T> range):
			if self.count + range.count > self.capacity:
				cdef realloc(handle, int) handle
				self.capacity = self.count + range.count
				self.buffer = realloc(self.buffer, self.capacity * sizeof(T))
			for i from 0 within range.count:
				self.buffer{self}[self.count + i] = range.buffer[i] as T
			self.count = self.count + range.count
		
		#def remove(fn<bool, T> compare) bool:
		#	for i from 0 within self.count:
		#		if compare(self.buffer[i] as T):
		#			cdef memcpy(handle, handle, int) handle
		#			memcpy(self.buffer + (i * sizeof(T)), self.buffer + ((i + 1) * sizeof(T)), (self.count - (i + 1)) * sizeof(T))
		#			return True
		#	return False
		
		#def toArray() array<T>:
		#	buffer = new T[self.count]
		#	for i from 0 within self.count:
		#		buffer[i] = self.buffer[i]
		#	return buffer
		
		def forall(fn<None, T> todo):
			for i from 0 within self.count:
				todo(self.buffer[i] as T)
		def sort(fn<int, T, T> compare):
			sorted = False
			while sorted == False:
				sorted = True
				for i from 1 within self.count:
					if compare(self.buffer[i] as T, self.buffer[i - 1] as T) > 0:
						
		
	class arrayList<T>:
		readonly T defaultValue
		array<T> buffer
		int count
		
		def __init__(int capacity, T defaultValue):
			self.buffer = new T[capacity](self.defaultValue = defaultValue)
			self.count = 0
		
		def pushBack(T elem):
			if self.count == (self.buffer as int):
				newBuffer = new T[self.count + 10](self.defaultValue)
				mem::memcpy(newBuffer, self.buffer, 0, 0, self.count)
				self.buffer = newBuffer
			self.buffer[self.count] = elem
			self.count = self.count + 1
		
		def addBuffer(array<T> buffer):
			if self.count + buffer as int >= self.buffer as int:
				newBuffer = new T[self.count + buffer as int](self.defaultValue)
				mem::memcpy(newBuffer, self.buffer, 0, 0, self.count)
				self.buffer = newBuffer
			mem::memcpy(self.buffer, buffer, self.count, 0, buffer as int)
			self.count = self.count + buffer as int
		def addRange(arrayList<T> range):
			if self.count + range.count >= self.buffer as int:
				newBuffer = new T[self.count + range.count](self.defaultValue)
				mem::memcpy(newBuffer, self.buffer, 0, 0, self.count)
				self.buffer = newBuffer
			mem::memcpy(self.buffer, range.buffer, self.count, 0, range.count)
			self.count = self.count + range.count
		
		def remove(fn<bool, T> toRemove) bool:
			i = 0
			while i < self.count:
				if toRemove(self.buffer[i]):
					mem::memcpy(self.buffer, self.buffer, i, i + 1, self.count - (1 + i))
					return True
				i = i + 1
			return False
		
		def toArray() array<T>:
			buffer = new T[self.count](self.defaultValue)
			i = 0
			while i < self.count:
				buffer[i] = self.buffer[i]
				i = i + 1
			return buffer
		
		def getAtIndex(int index) T:
			if index > self.count:
				abort "Index Over Range"
			elif index < 0:
				abort "Index Under Range"
			return self.buffer[index]
		
		def setAtIndex(int index, T elem) T:
			if index > self.count:
				abort "Index Over Range"
			elif index < 0:
				abort "Index Under Range"
			return self.buffer[index] = elem
		
		def forall(fn<nothing, T> todo):
			i = 0
			while i < self.count:
				todo(self.buffer[i])
				i = i + 1
		def sort(fn<int, T, T> compare):
			sorted = False
			while sorted == False:
				sorted = True
				i = 1
				while i < self.count:
					if compare(self.buffer[i - 1], self.buffer[i]) > 0:
						temp = self.buffer[i]
						self.buffer[i] = self.buffer[i - 1]
						self.buffer[i - 1] = temp
						sorted = False
					i = i + 1
		
		def map(fn<T, T> transform) arrayList<T>:
			mapped = new arrayList<T>(self.count, self.defaultValue)
			i = 0
			while i < self.count:
				mapped.pushBack(transform(self.buffer[i]))
				i = i + 1
			return mapped
		def filter(fn<bool, T> keepCond) arrayList<T>:
			filtered = new arrayList<T>(self.count, self.defaultValue)
			i = 0
			while i < self.count:
				if keepCond(self.buffer[i]):
					filtered.pushBack(self.buffer[i])
				i = i + 1
			return filtered
		def reduce(fn<T, T, T> add) T:
			accum = getAtIndex(0)
			i = 1
			while i < self.count:
				accum = add(accum, self.buffer[i])
				i = i + 1
			return accum