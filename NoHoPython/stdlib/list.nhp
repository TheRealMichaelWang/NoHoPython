mod data:
	def list_T_convertList<T, X>(list<T> input, fn<X, T> convert) list<X>:
		converted = new list<X>(input.count)
		for i from 0 within input.count:
			converted.pushBack(convert(input[i]))
		return converted
	
	class list<T>:
		handle<T> buffer
		int count = 0
		int capacity
		
		pure __init__(int capacity):
			self.capacity = capacity
			self.buffer = std::malloc(capacity)
		
		def __del__():
			for i from 0 within self.count:
				destroy self.buffer + i
			cstd::free(self.buffer)
		
		pure __copy__() list<T>:
			copied = new list<T>(self.count)
			copied.count = self.count
			for i from 0 within self.count:
				copied.buffer[i] = self.buffer[i]
			return copied
		
		def clear():
			for i from 0 within self.count:
				destroy self.buffer + i
			self.count = 0
		
		def getAtIndex(int i) T:
			if i < 0 or i >= self.count:
				abort "Index out of range."
			return self.buffer[i]
		
		def setAtIndex(int i, T elem) T:
			if i < 0 or i >= self.count:
				abort "Index out of range."
			destroy self.buffer + i
			return self.buffer[i] = elem
		
		def add(list<T> toadd) list<T>:
			res = new list<T>(self.count + toadd.count)
			res.addRange(self)
			res.addRange(toadd)
			return res
		
		def ensureCapacity(int capacity):
			if self.capacity >= capacity:
				return
			
			self.capacity = capacity + 10
			self.buffer = std::realloc(self.buffer, self.capacity)
		
		def pushFront(T elem):
			ensureCapacity(self.count + 1)
			std::memcpy(self.buffer + 1, self.buffer, self.count)
			self.buffer[0] = elem
			self.count = self.count + 1
		
		def pushBack(T elem):
			ensureCapacity(self.count + 1)
			self.buffer[self.count] = elem
			self.count = self.count + 1
		
		def insert(int index, T elem):
			ensureCapacity(self.count + 1)
			std::memcpy(self.buffer + (index + 1), self.buffer + index, self.count - index)
			self.buffer[index] = elem
			self.count = self.count + 1
		
		def addBuffer(array<T> buf):
			ensureCapacity(self.count + buf as int)
			for i from 0 within buf:
				self.buffer[self.count + i] = buf[i]
			self.count = self.count + buf as int
		
		def addRange(list<T> range):
			ensureCapacity(self.count + range.count)
			for i from 0 within range.count:
				self.buffer[self.count + i] = range.buffer[i] as T
			self.count = self.count + range.count
		
		def remove(fn<bool, T> compare) bool:
			for i from 0 within self.count:
				if compare(self.buffer[i] as T):
					destroy self.buffer + i
					std::memcpy(self.buffer + i, self.buffer + i + 1, self.count - (i + 1))
					self.count = self.count - 1
					return True
			return False

		def popFront() T:
			popped = getAtIndex(0)
			destroy self.buffer
			self.count = self.count - 1
			std::memcpy(self.buffer, self.buffer + 1, self.count)
			return popped
		
		def popBack() T:
			popped = getAtIndex(self.count - 1)
			self.count = self.count - 1
			destroy self.buffer + self.count
			return popped
		
		def to_array_T() array<T>:
			return marshal T[self.count](self.buffer)
		
		def forall(fn<None, T> todo):
			for i from 0 within self.count:
				todo(self.buffer[i])

		def forallWithIndex(fn<None, T, int> todo):
			for i from 0 within self.count:
				todo(self.buffer[i], i)
		
		def sort(fn<int, T, T> compare):
			sorted = False
			tempBuf = std::malloc(1) as handle<T>
			while sorted == False:
				sorted = True
				for i from 1 within self.count:
					if compare(self.buffer[i], self.buffer[i - 1]) < 0:
						larger = self.buffer + ((i - 1) * sizeof(T))
						smaller = self.buffer + (i * sizeof(T))
						std::memcpy(tempBuf, larger, 1)
						std::memcpy(larger, smaller, 1)
						std::memcpy(smaller, tempBuf, 1)
						sorted = False
			cstd::free(tempBuf)
		
		def map(fn<T, T> transform) list<T>:
			mapped = new list<T>(self.count)
			mapped.count = self.count
			for i from 0 within self.count:
				value = transform(self.buffer[i] as T)
				mapped.buffer[i] = value
			return mapped

		def filter(fn<bool, T> keep) list<T>:
			kept = new list<T>(self.count)
			for i from 0 within self.count:
				if keep(self.buffer[i] as T):
					kept.pushBack(self.buffer[i] as T)
			return kept
		
		def reduce(fn<T, T, T> combine) T:
			accum = getAtIndex(0)
			for i from 1 within self.count:
				accum = combine(accum, self.buffer[i] as T)
			return accum