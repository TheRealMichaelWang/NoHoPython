cinclude "<string.h>"
cinclude "<stdlib.h>"
include "list.nhp"

mod data:
	interface map<K, V>:
		fn<V, K> get
		fn<bool, K, V> emplace
		fn<bool, K> has
	
	class hashmap<K, V>:
		handle<int> keyBuckets
		handle<V> valueBuckets
		handle<bool> bucketStates
		int bucketCount
		
		fn<int, K> hasher
		
		def __init__(fn<int, K> hasher, int bucketCount):
			self.bucketCount = bucketCount
			self.hasher = hasher
			
			self.keyBuckets = std::malloc(bucketCount) as handle<int>
			self.valueBuckets = std::malloc(bucketCount) as handle<V>
			self.bucketStates = std::calloc(bucketCount) as handle<bool>

		def __copy__() hashmap<K, V>:
			copied = new hashmap<K, V>(self.hasher, self.bucketCount)
			for i from 0 within self.bucketCount:
				if self.bucketStates[i] as bool:
					copied.keyBuckets[i] = self.keyBuckets[i]
					copied.valueBuckets[i] = self.valueBuckets[i]
					copied.bucketStates[i] = True
			return copied

		def __del__():
			for i from 0 within self.bucketCount:
				if self.bucketStates[i] as bool:
					destroy self.valueBuckets + i

			cstd::free(self.keyBuckets)
			cstd::free(self.valueBuckets)
			cstd::free(self.bucketStates)
		
		def has(K key) bool:
			hash = self.hasher(key)
			for i from hash % self.bucketCount within self.bucketCount:
				if self.bucketStates[i] and self.keyBuckets[i] == hash:
					return True
			return False
		
		def get(K key) V:
			hash = self.hasher(key)
			for i from hash % self.bucketCount within self.bucketCount:
				if self.bucketStates[i] and self.keyBuckets[i] == hash:
					return self.valueBuckets[i]
			abort "Key not found"
		
		def emplace(K key, V toadd) bool:
			def internalEmplace(int hash, V value) bool:
				for i from hash % self.bucketCount within self.bucketCount:
					if self.bucketStates[i] == False: #empty bucket, claim it
						self.keyBuckets[i] = hash
						self.valueBuckets[i] = value
						self.bucketStates[i] = True
						return True
					elif self.keyBuckets[i] == hash:
						destroy self.valueBuckets + i
						self.valueBuckets[i] = value
						return False
				
				oldKeys = self.keyBuckets
				oldValues = self.valueBuckets
				oldBucketStates = self.bucketStates
				oldBucketCount = self.bucketCount
				
				self.bucketCount = self.bucketCount + 64
				self.keyBuckets = std::malloc(self.bucketCount) as handle<int>
				self.valueBuckets = std::malloc(self.bucketCount) as handle<V>
				self.bucketStates = std::calloc(self.bucketCount) as handle<bool>

				for i from 0 within oldBucketCount:
					if oldBucketStates[i] as bool:
						internalEmplace(oldKeys[i], oldValues[i])
						destroy oldValues + i
				
				cstd::free(oldKeys)
				cstd::free(oldValues)
				cstd::free(oldBucketStates)
				
				return internalEmplace(hash, value)
			
			return internalEmplace(self.hasher(key), toadd)
	
	class treemap<K, V>:
		fn<int, K, K> compare
		list<tuple<K, V>> buckets
		
		def __init__(fn<int, K, K> compare):
			self.compare = compare
			self.buckets = new list<tuple<K, V>>(10)
		
		def has(K key) bool:
			low = 0
			high = self.buckets.count
			while low < high:
				mid = (high + low) / 2
				
				bucket = self.buckets[mid]
				res = self.compare(key, bucket.K0)
				if res == 0: #exact match
					return True
				elif res > 0: #key is greater than pivot
					low = mid
				else: #key is smaller than pivot
					high = mid
			
			#key was never found
			return False
		
		def get(K key) V:
			low = 0
			high = self.buckets.count
			while low < high:
				mid = (high + low) / 2
				
				bucket = self.buckets[mid]
				res = self.compare(key, bucket.K0)
				if res == 0: #exact match
					return bucket.V0
				elif res > 0: #key is greater than pivot
					low = mid
				else: #key is smaller than pivot
					high = mid
			
			abort "Key not found"
		
		def emplace(K key, V value) bool:
			low = 0
			high = self.buckets.count
			while low < high:
				mid = (high + low) / 2
				
				bucket = self.buckets[mid]
				res = self.compare(key, bucket.K0)
				if res == 0: #exact match, overwrite bucket value
					self.buckets[mid] = (key, value)
					return False
				elif res > 0: #key is greater than pivot
					low = mid + 1
				else: #key is smaller than pivot
					high = mid
			
			#key was never found, actually insert
			self.buckets.insert(low, (key, value))
			return True