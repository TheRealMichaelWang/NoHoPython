mod std:
	cdef EOF char

	interface outputStream:
		fn<None, char> writeByte
		fn<int, array<char>> writeBuffer
		fn<None> flush
		
	interface inputStream:
		fn<char> readByte

	interface peekableStream:
		fn<char> readByte
		fn<char> peek
	
	class memoryWriter:
		handle<char> buffer
		
		int capacity
		int length
		
		def __init__(int capacity):
			self.capacity = capacity
			self.length = 0
			
			cdef malloc(int) handle<char>
			self.buffer = malloc(capacity)
			assert self.buffer != None
			
		def __del__():
			cdef free(handle<char>) None
			free(self.buffer)
			
		def __copy__() memoryWriter:
			cdef memcpy(handle<char>, handle<char>, int) handle<char>
			
			copied = new memoryWriter(self.length)
			memcpy(copied.buffer, self.buffer, self.length)
			copied.length = self.length
			
			return copied
			
		def to_array_char() array<char>:
			return marshal char[self.length](self.buffer)
			
		def ensureCapacity(int minCap):
			cdef realloc(handle<char>, int) handle<char>

			if self.capacity < minCap:
				self.capacity = minCap
				self.buffer = realloc(self.buffer, minCap)
				assert self.buffer != None

		def writeByte(char byte):
			ensureCapacity(self.length + 1)

			self.buffer[self.length] = byte
			self.length = self.length + 1

		def writeBuffer(array<char> buffer) int:
			cdef memcpy(handle<char>, handle<char>, int) None

			ensureCapacity(self.length + buffer as int)
			memcpy(self.buffer + self.length, buffer, buffer)

			return buffer as int

		def flush():
			return
	
	class memoryReader:
		handle<char> buffer
		int position = 0
		int length
		
		def __init__(handle<char> buffer, int length):
			self.buffer = buffer
			self.length = length
			
		def readByte() char:
			if self.position == self.length:
				return EOF
			toret = self.buffer[self.position]
			self.position = self.position + 1
			return toret

		def peek() char:
			if self.position == self.length:
				return EOF
			return self.buffer[self.position]

	class bufferedWriter:
		memoryWriter buffer
		int capacity

		outputStream innerWriter

		def __init__(outputStream innerWriter, int capacity):
			self.innerWriter = innerWriter
			self.capacity = capacity

			self.buffer = new memoryWriter(capacity)

		def ensureFlushed():
			if self.buffer.length >= self.capacity:
				flush()

		def writeByte(char byte):
			self.buffer.writeByte(byte)
			ensureFlushed()

		def writeBuffer(array<char> buffer):
			self.buffer.writeBuffer(buffer)
			ensureFlushed()

		def flush():
			if self.buffer.length == 0:
				return

			currentBuf = self.buffer as array<char>
			self.innerWriter.writeBuffer(currentBuf)
			self.innerWriter.flush()

			self.buffer.length = 0

	mod stream:
		def read(inputStream input, array<char> dest, int offset, int length) int:
			readBytes = 0
			
			for i from 0 within length:
				byte = input.readByte()
				
				if byte == EOF:
					break

				dest[offset + i] = byte
				readBytes = readBytes + 1
			
			return readBytes

		def readLine(inputStream input) array<char>:
			writer = new memoryWriter(64)

			while True:
				c = input.readByte()

				if c == '\n' or c == EOF:
					return writer
				else:
					writer.writeByte(c)

		def readToEnd(inputStream input) array<char>:
			writer = new memoryWriter(64)

			while True:
				c = input.readByte()

				if c == EOF:
					return writer
				else:
					writer.writeByte(c)

		def write(outputStream output, array<char> src, int offset, int length):
			writeBuf = new char[length]

			for i from 0 within length:
				writeBuf[i] = src[offset + i]

			output.writeBuffer(writeBuf)