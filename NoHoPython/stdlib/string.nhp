#North Hollywood Python Standard Library

#string.nhp
#This file contains the standard library definiton of the string class, which is the usual type of all string literals. Do not modify or remove this file.

mod std:
	#like c-sharp StringBuilder, stringBuilder in nhp can construct variable length strings performantly
	class stringBuilder:
		handle<char> cstr
		int length = 0
		int capacity

		def __init__(int capacity):
			cdef malloc(int) handle<char>

			self.capacity = capacity
			self.cstr = malloc(capacity)
			assert self.cstr != None

		def __copy__() stringBuilder:
			cdef memcpy(handle<char>, handle<char>, int) None

			copiedBuilder = new stringBuilder(self.length)
			memcpy(copiedBuilder.cstr, self.cstr, self.length)
			copiedBuilder.length = self.length

			return copiedBuilder

		def __del__():
			cdef free(handle<char>) None
			free(self.cstr)

		def to_string() string:
			newCStr = std::malloc(self.length + 1) as handle<char>
			assert newCStr != None

			memcpy(newCStr, self.cstr, self.length)
			newCStr[self.length] = 0 as char

			return new string(newCStr, false)

		def ensureCapacity(int newCapacity):
			cdef realloc(handle<char>, int) handle<char>

			if newCapacity <= self.capacity:
				return

			self.capacity = newCapacity
			self.cstr = realloc(self.cstr, self.capacity)
			assert self.cstr != None

		def appendChar(char c):
			ensureCapacity(self.length + 1)
			self.cstr[self.length] = c
			self.length = self.length + 1

		def appendCPtr(handle<char> str, int length):
			cdef memcpy(handle<char>, handle<char>, int) None

			if length == 0:
				return

			ensureCapacity(length + self.capacity)

			memcpy(self.cstr + self.length, str, length)
			self.length = self.length + length

		def appendCStr(handle<char> cstr):
			cdef strlen(handle<char>) int
			appendCPtr(cstr, strlen(cstr))

		def appendArray(array<char> str):
			appendCPtr(str as handle<char>, str as int)

		def append(string str):
			appendCPtr(str.cstr, str.length)

	def makeString(array<char> buf) string:
		cstr = std::malloc(buf as int + 1) as handle<char>
		assert cstr != None

		memcpy(cstr, buf, buf)
		cstr[buf as int] = 0 as char

		return new string(cstr, false)

	def strcmp(string a, string b) int:
		return a.compare(b)

	def fastStrcmp(string a, string b) int:
		return a.hash - b.hash

	#dj2b is a simple hashing algorithm
	def dj2b(handle<char> str, int length) int:
		hash = 5381

		for i from 0 within length:
			#hash = hash * 33 + c
			hash = ((hash lshift 5) + hash) + str[i]

		return hash

#default definition of a string. This is not a built in class per say, but all string literals are turned into the class defined below. DO NOT MODIFY
class string:
	handle<char> cstr
	bool isStatic
	
	int length
	int hash
	
	def __init__(handle<char> cstr, bool isStatic):
		cdef strlen(handle<char>) int
		
		self.cstr = cstr
		self.isStatic = isStatic
		self.length = strlen(cstr)
		self.hash = std::dj2b(cstr, self.length)
		
	def __copy__() string:
		cdef strcpy(handle<char>, handle<char>) None
		
		newCStr = std::malloc(self.length + 1) as handle<char>
		assert newCStr != None
		
		strcpy(newCStr, self.cstr)
		
		return new string(newCStr, false)
		
	def __del__():
		if self.isStatic == False:
			cstd::free(self.cstr)
			
	def to_array_char() array<char>:
		return marshal char[self.length](self.cstr)

	def to_int() int:
		cdef atol(handle<char>) int
		return atol(self.cstr)

	def to_dec() dec:
		cdef atof(handle<char>) dec
		return atof(self.cstr)
	
	def compare(string s) int:
		cdef strcmp(handle<char>, handle<char>) int
		return strcmp(self.cstr, s.cstr)
	
	def getAtIndex(int i) char:
		assert i >= 0 and i < self.length
		return self.cstr[i]
		
	def add(string str) string:
		concatCStr = std::malloc(self.length + str.length + 1) as handle<char>
		assert concatCStr != None
		
		std::memcpy(concatCStr, self.cstr, self.length)
		std::memcpy(concatCStr + self.length, str.cstr, str.length)
		concatCStr[self.length + str.length] = 0 as char
		
		return new string(concatCStr, false)
		
	def substring(int i, int length) string:
		assert i >= 0 and i < self.length
		assert i + length <= self.length
		
		destCStr = std::malloc(length + 1) as handle<char>
		assert destCStr != None
		
		std::memcpy(destCStr, self.cstr + i, length)
		destCStr[length] = 0 as char
		
		return new string(destCStr, false)
		
	def find(string substr, int startIndex) int:
		def matchPattern(int offset) bool:
			for i from 0 within substr.length:
				if self.cstr[i + offset] as char != substr.cstr[i] as char:
					return false
			return true
			
		for i from startIndex within self.length - substr.length:
			if matchPattern(i):
				return i
		return -1
		
	def contains(string substr) bool:
		return find(substr, 0) != -1
		
	def replace(string findStr, string replaceStr) string:
		builder = new std::stringBuilder(self.length)
		
		i = 0
		while True:
			end = find(findStr, i)
			if end == -1:
				builder.appendCPtr(self.cstr + i, self.length - i)
				return builder
			else:
				builder.appendCPtr(self.cstr + i, end - i)
				builder.append(replaceStr)
				i = end + findStr.length
				
	def split(string delim, bool includeEmpty) array<string>:
		parts = new data::list<string>(10)

		i = 0
		while True:
			end = find(delim, i)
			if end == -1:
				if i != self.length:
					parts.pushBack(substring(i, self.length - i))
				
				return parts.toArray()
			else:
				if end != i:
					parts.pushBack(substring(i, end - i))
				
				i = end + delim.length