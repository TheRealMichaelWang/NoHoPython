#North Hollywood Python Standard Library

#string.nhp
#This file contains the standard library definiton of the string class, which is the usual type of all string literals. Do not modify or remove this file.

mod std:
	#like c-sharp StringBuilder, stringBuilder in nhp can construct variable length strings performantly
	class stringBuilder:
		handle cstr
		int length = 0
		int capacity

		def __init__(int capacity):
			cdef malloc(int) handle

			self.capacity = capacity
			self.cstr = malloc(capacity)
			assert self.cstr != NULL

		def __copy__() stringBuilder:
			cdef memcpy(handle, handle, int) None

			copiedBuilder = new stringBuilder(self.length)
			memcpy(copiedBuilder.cstr, self.cstr, self.length)
			copiedBuilder.length = self.length

			return copiedBuilder

		def __del__():
			cdef free(handle) None
			free(self.cstr)

		def to_string() string:
			cdef malloc(int) handle
			cdef memcpy(handle, handle, int) None

			newCStr = malloc(self.length + 1)
			assert newCStr != NULL

			memcpy(newCStr, self.cstr, self.length)
			newCStr[self.length] = 0 as char

			return new string(newCStr, false)

		def ensureCapacity(int newCapacity):
			cdef realloc(handle, int) handle

			if newCapacity <= self.capacity:
				return

			self.capacity = newCapacity
			self.cstr = realloc(self.cstr, self.capacity)
			assert self.cstr != NULL

		def appendChar(char c):
			ensureCapacity(self.length + 1)
			self.cstr[self.length] = c
			self.length = self.length + 1

		def appendCPtr(handle str, int length):
			cdef memcpy(handle, handle, int) None

			if length == 0:
				return

			ensureCapacity(length + self.capacity)

			memcpy(self.cstr as int + self.length, str, length)
			self.length = self.length + length

		def appendCStr(handle cstr):
			cdef strlen(handle) int
			appendCPtr(cstr, strlen(cstr))

		def appendArray(array<char> str):
			appendCPtr(str as handle, str as int)

		def append(string str):
			appendCPtr(str.cstr, str.length)

	def makeString(array<char> buf) string:
		cdef malloc(int) handle
		cdef memcpy(handle, handle, int) None

		cstr = malloc(buf as int + 1)
		assert cstr != NULL

		memcpy(cstr, buf, buf)
		cstr[buf as int] = 0 as char

		return new string(cstr, false)

	def strcmp(string a, string b) int:
		return a.compare(b)

	def fastStrcmp(string a, string b) int:
		return a.hash - b.hash

	#dj2b is a simple hashing algorithm
	def dj2b(handle str, int length) int:
		hash = 5381

		for i from 0 within length:
			#hash = hash * 33 + c
			hash = ((hash lshift 5) + hash) + (str[i] as char)

		return hash

#default definition of a string. This is not a built in class per say, but all string literals are turned into the class defined below. DO NOT MODIFY
class string:
	handle cstr
	bool isStatic
	
	int length
	int hash
	
	def __init__(handle cstr, bool isStatic):
		cdef strlen(handle) int
		
		self.cstr = cstr
		self.isStatic = isStatic
		self.length = strlen(cstr)
		self.hash = std::dj2b(cstr, self.length)
		
	def __copy__() string:
		cdef malloc(int) handle
		cdef strcpy(handle, handle) None
		
		newCStr = malloc(self.length + 1)
		assert newCStr != NULL
		
		strcpy(newCStr, self.cstr)
		
		return new string(newCStr, false)
		
	def __del__():
		cdef free(handle) None
		if self.isStatic == False:
			free(self.cstr)
			
	def to_array_char() array<char>:
		return marshal char[self.length](self.cstr)

	def to_int() int:
		cdef atol(handle) int
		return atol(self.cstr)

	def to_dec() dec:
		cdef atof(handle) dec
		return atof(self.cstr)
	
	def compare(string s) int:
		cdef strcmp(handle, handle) int
		return strcmp(self.cstr, s.cstr)
	
	def getAtIndex(int i) char:
		assert i >= 0 and i < self.length
		return self.cstr[i] as char
		
	def add(string str) string:
		cdef malloc(int) handle
		cdef memcpy(handle, handle, int) None
		
		concatCStr = malloc(self.length + str.length + 1)
		assert concatCStr != NULL
		
		memcpy(concatCStr, self.cstr, self.length)
		memcpy((concatCStr as int + self.length), str.cstr, str.length)
		concatCStr[self.length + str.length] = 0 as char
		
		return new string(concatCStr, false)
		
	def substring(int i, int length) string:
		cdef malloc(int) handle
		cdef memcpy(handle, handle, int) None
		
		assert i >= 0 and i < self.length
		assert i + length <= self.length
		
		destCStr = malloc(length + 1)
		assert destCStr != NULL
		
		memcpy(destCStr, (self.cstr as int + i), length)
		destCStr[length] = 0 as char
		
		return new string(destCStr, false)
		
	def find(string substr, int startIndex) int:
		def matchPattern(int offset) bool:
			for i from 0 within substr.length:
				if self.cstr[i + offset] as char != substr.cstr[i] as char:
					return false
			return true
			
		for i from startIndex within self.length - substr.length:
			if matchPattern(i):
				return i
		return -1
		
	def contains(string substr) bool:
		return find(substr, 0) != -1
		
	def replace(string findStr, string replaceStr) string:
		builder = new std::stringBuilder(self.length)
		
		i = 0
		while True:
			end = find(findStr, i)
			if end == -1:
				builder.appendCPtr(self.cstr as int + i, self.length - i)
				return builder
			else:
				builder.appendCPtr(self.cstr as int + i, end - i)
				builder.append(replaceStr)
				i = end + findStr.length
				
	def split(string delim, bool includeEmpty) array<string>:
		parts = new data::list<string>(10)

		i = 0
		while True:
			end = find(delim, i)
			if end == -1:
				if i != self.length:
					parts.pushBack(substring(i, self.length - i))
				
				return parts.toArray()
			else:
				if end != i:
					parts.pushBack(substring(i, end - i))
				
				i = end + delim.length